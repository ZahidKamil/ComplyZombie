import type { ComplianceReport } from '../types/compliance';

/**
 * ====================================================================
 * S3 SERVICE - Handles fetching compliance reports from AWS S3
 * ====================================================================
 * 
 * This service provides functions to fetch compliance reports that were
 * generated by our AWS Lambda scanner and stored in S3.
 * 
 * S3 Bucket Structure:
 * s3://grc-compliance-reports/
 *   ‚îî‚îÄ‚îÄ reports/
 *       ‚îú‚îÄ‚îÄ latest.json                          ‚Üê Always points to newest report
 *       ‚îú‚îÄ‚îÄ compliance-20260104-143000.json      ‚Üê Timestamped reports (archived)
 *       ‚îú‚îÄ‚îÄ compliance-20260103-120000.json
 *       ‚îî‚îÄ‚îÄ ...
 */

// ====================================================================
// CONFIGURATION
// ====================================================================

/**
 * The name of your S3 bucket where compliance reports are stored.
 * This bucket is where your Lambda function saves scan results.
 */
const S3_BUCKET_NAME = 'grc-compliance-reports';

/**
 * The AWS region where your S3 bucket is located.
 * Must match the region where you created the bucket.
 */
const S3_REGION = 'us-east-1';


// ====================================================================
// HELPER FUNCTIONS
// ====================================================================

/**
 * Constructs the full public S3 URL for a given object key.
 * 
 * @param key - The S3 object key (e.g., "reports/latest.json")
 * @returns The complete HTTPS URL to access the object
 * 
 * Example:
 *   getS3Url("reports/latest.json")
 *   ‚Üí "https://grc-compliance-reports.s3.us-east-1.amazonaws.com/reports/latest.json"
 */
function getS3Url(key: string): string {
  return `https://${S3_BUCKET_NAME}.s3.${S3_REGION}.amazonaws.com/${key}`;
}


// ====================================================================
// PUBLIC FUNCTIONS
// ====================================================================

/**
 * Fetches the latest compliance report from S3.
 * 
 * This function always retrieves the most recent scan by fetching
 * the "latest.json" file, which Lambda updates after each scan.
 * 
 * @returns Promise that resolves to the complete compliance report
 * @throws Error if the fetch fails or the report is malformed
 * 
 * How it works:
 * 1. Lambda runs a compliance scan
 * 2. Lambda saves results to timestamped file (e.g., compliance-20260104-143000.json)
 * 3. Lambda ALSO saves same data to "latest.json" (overwrites previous)
 * 4. This function always fetches "latest.json" to get newest data
 * 
 * Why this approach?
 * - Simple: No need to list all objects and find the newest
 * - Fast: Direct fetch, no API calls to list objects
 * - Reliable: Always guaranteed to be the most recent
 */
export async function fetchLatestReport(): Promise<ComplianceReport> {
  try {
    // Construct the URL for the "latest.json" file
    // This file is always overwritten by Lambda with the newest scan
    const reportKey = 'reports/latest.json';
    const url = getS3Url(reportKey);
    
    // Log what we're doing (helpful for debugging)
    console.log('üì° Fetching latest compliance report from S3...');
    console.log('üîó URL:', url);
    
    // Make the HTTP request to S3
    // fetch() is a browser API that retrieves data from a URL
    const response = await fetch(url);
    
    // Check if the request was successful
    // response.ok is true if status is 200-299
    if (!response.ok) {
      // If not successful, throw an error with details
      throw new Error(
        `Failed to fetch report: HTTP ${response.status} ${response.statusText}`
      );
    }
    
    // Parse the JSON response into our TypeScript type
    // This validates the data structure matches our ComplianceReport interface
    const data: ComplianceReport = await response.json();
    
    // Log success with some key details
    console.log('‚úÖ Successfully loaded latest report from S3');
    console.log('üìä Overall Score:', data.executive_summary.overall_score + '%');
    console.log('üìÖ Scan Time:', new Date(data.scan_metadata.scan_time).toLocaleString());
    console.log('üéØ Total Checks:', data.executive_summary.total_checks);
    console.log('‚úì Passed:', data.executive_summary.passed);
    console.log('‚úó Failed:', data.executive_summary.failed);
    
    // Return the parsed data
    return data;
    
  } catch (error) {
    // If anything goes wrong, log the error and re-throw it
    // This allows the calling component to handle the error
    console.error('‚ùå Error fetching latest S3 report:', error);
    
    // Add more context to the error
    if (error instanceof Error) {
      throw new Error(`S3 fetch failed: ${error.message}`);
    }
    
    throw error;
  }
}


/**
 * Fetches a specific historical compliance report by its timestamp.
 * 
 * Useful for viewing past scans or comparing trends over time.
 * 
 * @param timestamp - The timestamp in format "YYYYMMDD-HHMMSS" (e.g., "20260104-143000")
 * @returns Promise that resolves to the compliance report from that time
 * @throws Error if the report doesn't exist or fetch fails
 * 
 * Example usage:
 *   fetchReportByTimestamp("20260104-143000")
 *   ‚Üí Fetches reports/compliance-20260104-143000.json
 */
export async function fetchReportByTimestamp(timestamp: string): Promise<ComplianceReport> {
  try {
    // Construct the filename from the timestamp
    const reportKey = `reports/compliance-${timestamp}.json`;
    const url = getS3Url(reportKey);
    
    console.log('üì° Fetching specific report:', timestamp);
    console.log('üîó URL:', url);
    
    // Fetch the specific report
    const response = await fetch(url);
    
    // Check if it exists
    if (!response.ok) {
      if (response.status === 404) {
        // 404 = Not Found - report doesn't exist
        throw new Error(`Report not found for timestamp: ${timestamp}`);
      }
      throw new Error(`Failed to fetch report: HTTP ${response.status}`);
    }
    
    // Parse and return the report
    const data: ComplianceReport = await response.json();
    console.log('‚úÖ Successfully loaded historical report');
    
    return data;
    
  } catch (error) {
    console.error(`‚ùå Error fetching report for ${timestamp}:`, error);
    throw error;
  }
}


/**
 * Lists all available compliance reports in S3.
 * 
 * NOTE: This requires either:
 * 1. AWS SDK with credentials (complex, not ideal for browser)
 * 2. A backend API that lists objects (we'll implement this later with FastAPI)
 * 
 * For now, this is a placeholder that returns mock data.
 * We'll implement this properly when we add the FastAPI backend.
 * 
 * @returns Promise that resolves to an array of report metadata
 */
export async function listAvailableReports(): Promise<Array<{
  timestamp: string;
  filename: string;
  scanTime: string;
}>> {
  // TODO: Implement this when we add FastAPI backend
  // For now, return empty array
  console.warn('‚ö†Ô∏è listAvailableReports() not yet implemented');
  console.log('üí° This will be implemented with FastAPI backend');
  
  return [];
}


/**
 * Generates mock compliance data for development/testing.
 * 
 * This is used as a fallback when S3 is unavailable or during development
 * without AWS access.
 * 
 * @returns A mock compliance report with realistic-looking data
 * 
 * Why we need this:
 * - Allows frontend development without AWS access
 * - Useful for testing UI with different data scenarios
 * - Fallback when S3 is down or misconfigured
 */
export function getMockReport(): ComplianceReport {
  // Generate a mock report with realistic data
  // This matches the structure of real Lambda reports
  return {
    scan_metadata: {
      scan_time: new Date().toISOString(),  // Current timestamp
      scanner_version: '2.0',
      execution_id: 'mock-execution-' + Math.random().toString(36).substring(7),
      aws_account: '123456789012'  // Fake AWS account ID
    },
    executive_summary: {
      overall_score: 73.5,
      total_checks: 34,
      passed: 25,
      failed: 5,
      warnings: 4,
      risk_level: 'MEDIUM'
    },
    framework_scores: [
      // Mock scores for each compliance framework
      { name: 'SOC 2', score: 78, total: 20, passed: 15, failed: 3, warnings: 2 },
      { name: 'ISO 27001', score: 72, total: 25, passed: 18, failed: 5, warnings: 2 },
      { name: 'NIST CSF', score: 70, total: 23, passed: 16, failed: 5, warnings: 2 },
      { name: 'PCI-DSS', score: 80, total: 15, passed: 12, failed: 2, warnings: 1 },
      { name: 'HIPAA', score: 75, total: 12, passed: 9, failed: 2, warnings: 1 }
    ],
    critical_findings: [
      // Mock critical security findings
      {
        severity: 'high',
        control_id: 'S3-002-data-bucket',
        control_name: 'Public Access Block',
        framework: 'SOC 2',
        details: 'S3 bucket allows public access - potential data breach risk',
        resource: 'data-bucket',
        timestamp: new Date().toISOString()
      },
      {
        severity: 'high',
        control_id: 'EC2-SG-001-web-sg',
        control_name: 'Security Group Rules',
        framework: 'SOC 2',
        details: 'Security group allows SSH from anywhere (0.0.0.0/0)',
        resource: 'web-sg (sg-12345678)',
        timestamp: new Date().toISOString()
      }
    ],
    detailed_controls: [
      // Mock individual control checks
      {
        control_id: 'IAM-001',
        control_name: 'MFA Enforcement',
        status: 'passed',
        frameworks: ['SOC 2', 'ISO 27001', 'NIST CSF', 'PCI-DSS'],
        framework: 'SOC 2',
        details: 'Root account has MFA enabled',
        timestamp: new Date().toISOString()
      },
      {
        control_id: 'IAM-004',
        control_name: 'Password Policy',
        status: 'warning',
        frameworks: ['SOC 2', 'ISO 27001', 'NIST CSF', 'HIPAA'],
        framework: 'NIST CSF',
        details: 'Password length requirement is below 14 characters',
        timestamp: new Date().toISOString()
      },
      {
        control_id: 'S3-001-prod-data',
        control_name: 'Bucket Encryption',
        status: 'failed',
        frameworks: ['SOC 2', 'ISO 27001', 'HIPAA', 'PCI-DSS'],
        framework: 'ISO 27001',
        details: 'S3 bucket encryption is not configured',
        timestamp: new Date().toISOString(),
        bucket: 'prod-data'
      }
    ]
  };
}